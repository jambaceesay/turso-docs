---
title: Reference
description: libSQL Rust Reference
---

## Installing

Install the package in your project using the following command:

```bash
cargo add libsql
```

## Initializing

Make sure add crate to your project at the top of your file:

```rust Turso
use libsql::Builder;

let db = Builder::new_local(":memory:").build().await.unwrap();
let conn = db.connect().unwrap();
conn.execute("CREATE TABLE IF NOT EXISTS users (email TEXT)", ()).await.unwrap();
conn.execute("INSERT INTO users (email) VALUES ('alice@example.org')", ()).await.unwrap();
```

## Local Development

You can work locally using an SQLite file using `new_local`:

```rust
use libsql::Builder;

let mut db = Builder::new_local("local.db").build().await.unwrap();
let conn = db.connect().unwrap();
```

## Embedded Replicas

You can work with embedded replicas using `new_remote_replica` that can sync from the remote URL and delegate writes to the remote primary database:

```rust
use libsql::Builder;

let url = env::var("LIBSQL_URL").expect("LIBSQL_URL must be set");
let token = env::var("LIBSQL_AUTH_TOKEN").unwrap_or_default();

let mut db = Builder::new_remote_replica("local.db", &url, &token).build().await.unwrap();
let conn = db.connect().unwrap();
```

TODO: Mention `new_local_replica`

## Simple query

You can pass a string to `execute()` to invoke a SQL statement, as well as optional arguments:

<CodeGroup>

```rust Query
conn.execute("SELECT * FROM users").await?;
```

```rust Arguments
conn.execute("SELECT * FROM users WHERE id = ?1", [1]).await?;
```

</CodeGroup>

## Prepared Statements

You can prepare a cached statement using `prepare()` and then execute it with `query()`:

```rust
let stmt = db_conn.prepare("SELECT * FROM users").await?;

db_conn.query(&stmt, &[&1]).await?;
```

## Placeholders

libSQL supports the use of positional and named placeholders within SQL statements:

<CodeGroup>

```rust Positional
conn.execute("SELECT * FROM users WHERE id = ?1", params![1]).await?;
```

```rust Named
conn.execute("INSERT INTO users (name) VALUES (:name)", libsql::named_params! { ":name": "Iku" }).await?;
```

</CodeGroup>

## Batch Transactions

A batch consists of multiple SQL statements executed sequentially within an implicit transaction. The backend handles the transaction: success commits all changes, while any failure results in a full rollback with no modifications.

```rust
conn.execute_batch(r#"
  CREATE TABLE IF NOT EXISTS users (
    id INTEGER PRIMARY KEY,
    name TEXT NOT NULL
  );

  INSERT INTO users (name) VALUES ('Alice');
  INSERT INTO users (name) VALUES ('Bob');
"#).await?;
```

## Deserialization

You can use the `de::from_row` function to deserialize a row into a struct:

```rust
use libsql::{de, Builder};

let mut stmt = conn
  .prepare("SELECT * FROM users WHERE id = ?1")
  .await
  .unwrap();
let row = stmt
  .query([1])
  .await
  .unwrap()
  .next()
  .await
  .unwrap()
  .unwrap();

#[derive(Debug, serde::Deserialize)]
#[allow(dead_code)]
struct User {
  name: String,
  age: i64,
  vision: f64,
  avatar: Vec<u8>,
}

let user = de::from_row::<User>(&row).unwrap();
```
