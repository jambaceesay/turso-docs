---
title: Reference
description: libSQL Rust Reference
---

The libSQL Rust crate contains everything you need to work with Turso and asynchronous Rust.

## Installing

Install the package in your project using the following command:

```bash
cargo add libsql
```

## Initializing

Make sure add crate to your project at the top of your file:

```rust Turso
use libsql::Builder;

let db = Builder::new_local(":memory:").build().await.unwrap();
let conn = db.connect().unwrap();

conn.execute("CREATE TABLE IF NOT EXISTS users (email TEXT)", ()).await.unwrap();
conn.execute("INSERT INTO users (email) VALUES ('alice@example.org')", ()).await.unwrap();
```

### Custom HTTP Connector

The `connector` function is used to provide a custom HTTP connector for creating HTTP connections, which might be necessary for custom networking setups, proxy configurations, or specialized security requirements.

## Local Development

You can work locally using an SQLite file using `new_local`:

```rust
use libsql::Builder;

let mut db = Builder::new_local("local.db").build().await.unwrap();
let conn = db.connect().unwrap();
```

## Embedded Replicas

You can work with embedded replicas using `new_remote_replica` that can sync from the remote URL and delegate writes to the remote primary database:

```rust
use libsql::Builder;

let url = env::var("LIBSQL_URL").expect("LIBSQL_URL must be set");
let token = env::var("LIBSQL_AUTH_TOKEN").unwrap_or_default();

let mut db = Builder::new_remote_replica("local.db", &url, &token).build().await.unwrap();
let conn = db.connect().unwrap();
```

### Manual Sync

The `sync` function allows you to sync manually the local database with the remote counterpart:

```rust
use libsql::Builder;

let url = env::var("LIBSQL_URL").expect("LIBSQL_URL must be set");
let token = env::var("LIBSQL_AUTH_TOKEN").unwrap_or_default();

let mut db = Builder::new_remote_replica("local.db", &url, &token).build().await.unwrap();

let conn = db.connect().unwrap();

db.sync().await.unwrap(); // Call sync manually to update local database
```

<Info>

If you require full control over how frames get from your instance of `sqld` (libSQL Server), you can do this using `new_local_replica` and `sync_frames`. Reach out to us [on Discord](https://discord.com/invite/4B5D7hYwub) if you want to learn more.

</Info>

### Periodic Sync

The `periodic_sync` function allows you to set an interval for automatic synchronization of the database in the background:

```rust
use libsql::Builder;
use std::time::Duration;

let url = env::var("LIBSQL_URL").expect("LIBSQL_URL must be set");
let token = env::var("LIBSQL_AUTH_TOKEN").unwrap_or_default();

let mut db = Builder::new_remote_replica("local.db", &url, &token)
  .periodic_sync(Duration::from_secs(300)) // Sync every 5 minutes
  .build()
  .await.unwrap();

let conn = db.connect().unwrap();
```

### Read Your Own Writes

The `read_your_writes` function configures the database connection to ensure that writes are immediately visible to subsequent read operations initiated by the same connection. This is particularly important in distributed systems to ensure consistency from the perspective of the writing process.

```rust
use libsql::Builder;

let url = env::var("LIBSQL_URL").expect("LIBSQL_URL must be set");
let token = env::var("LIBSQL_AUTH_TOKEN").unwrap_or_default();

let mut db = Builder::new_remote_replica("local.db", &url, &token)
  .read_your_writes(true) // Enable reading your own writes
  .build()
  .await.unwrap();

let conn = db.connect().unwrap();
```

## Encryption

To enable encryption on a SQLite file (`new_local` or `new_remote_replica`), pass the `encryption_config`:

```rust
use libsql::Builder;
use bytes::Bytes;

let url = env::var("LIBSQL_URL").expect("LIBSQL_URL must be set");
let token = env::var("LIBSQL_AUTH_TOKEN").unwrap_or_default();

let cipher = Cipher::YourChosenCipher;
let encryption_key_bytes = Bytes::from("your_secure_encryption_key_here");

let encryption_config = EncryptionConfig {
    cipher,
    encryption_key: encryption_key_bytes,
};

let mut db = Builder::new_remote_replica("local.db", &url, &token)
  .encryption_config(encryption_config) // Apply encryption configuration
  .build()
  .await.unwrap();

let conn = db.connect().unwrap();
```

<Info>

Encrypted databases appear as raw data and cannot be read as standard SQLite databases. You must use the libSQL client for any operations â€” [learn more](/libsql#encryption-at-rest).

</Info>

## Simple query

You can pass a string to `execute()` to invoke a SQL statement, as well as optional arguments:

<CodeGroup>

```rust Query
conn.execute("SELECT * FROM users").await?;
```

```rust Arguments
conn.execute("SELECT * FROM users WHERE id = ?1", [1]).await?;
```

</CodeGroup>

## Prepared Statements

You can prepare a cached statement using `prepare()` and then execute it with `query()`:

```rust
let stmt = db_conn.prepare("SELECT * FROM users").await?;

db_conn.query(&stmt, &[&1]).await?;
```

## Placeholders

libSQL supports the use of positional and named placeholders within SQL statements:

<CodeGroup>

```rust Positional
conn.execute("SELECT * FROM users WHERE id = ?1", params![1]).await?;
```

```rust Named
conn.execute("INSERT INTO users (name) VALUES (:name)", libsql::named_params! { ":name": "Iku" }).await?;
```

</CodeGroup>

## Batch Transactions

A batch consists of multiple SQL statements executed sequentially within an implicit transaction. The backend handles the transaction: success commits all changes, while any failure results in a full rollback with no modifications.

```rust
conn.execute_batch(r#"
  CREATE TABLE IF NOT EXISTS users (
    id INTEGER PRIMARY KEY,
    name TEXT NOT NULL
  );

  INSERT INTO users (name) VALUES ('Alice');
  INSERT INTO users (name) VALUES ('Bob');
"#).await?;
```

## Deserialization

You can use the `de::from_row` function to deserialize a row into a struct:

```rust
use libsql::{de, Builder};

let mut stmt = conn
  .prepare("SELECT * FROM users WHERE id = ?1")
  .await
  .unwrap();
let row = stmt
  .query([1])
  .await
  .unwrap()
  .next()
  .await
  .unwrap()
  .unwrap();

#[derive(Debug, serde::Deserialize)]
#[allow(dead_code)]
struct User {
  name: String,
  age: i64,
  vision: f64,
  avatar: Vec<u8>,
}

let user = de::from_row::<User>(&row).unwrap();
```
